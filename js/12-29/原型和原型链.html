<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型和原型对象</title>
</head>
<body>
    <script>
        // 每一个引用类型都有一个构造函数
        function Person(name, age) {
            this.name = name;
            this.age = age;
        }

        // 每一个构造函数都一个 prototype 属性, 这个属性指向的是 原型对象
        // Person.prototype 就是一个原型对象
        // 在原型对象上 添加一个 address 属性
        // 原型对象的属性和方法是共享的
        
        Person.prototype.address = '中原地区';

        var person1 = new Person('kevin', 20);  // 通过 new操作符 实例化 一个对象
        var person2 = new Person('john', 18);  // 通过 new操作符 实例化 一个对象
        console.log(person1);
        console.log(person1.name, person1.age);
        person1.address = '二七区'; // 给 当前实例 添加方法, 自己独有的
        console.log(person1.address, person1);
        console.log(person2.address, person2);

        console.log(Person.prototype === person1.__proto__);
        console.log(Person.prototype.constructor  === Person);

        // console.log(person1.address);  // 当我们去找某个引用类型(当前实例)上的属性和方法时,它先会在 自身 上去找, 如果有就直接读取结束; 如果没有, 会沿着 构造函数的 prototype 属性指向的 原型对象 去找,(当前实例上的一个 __proto__ 指向的原型对象去找), 如果有读取其值
    </script>
</body>
</html>